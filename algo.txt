
==Sorting==
71. r은 십진수의 10에 해당함. 자리수만큼 달라짐
75. 179자리 -> 271 (*오류*) . 데이터의 끝자리 숫자에 맞춰서 어레이 번호에 맞게 쌓음. f는 1의 자리수로 소팅이 되어있음.
76. 10의 자리수로 정렬. 앞 패스에서 이미 1의 자리수로 정렬되어 있기에 같은 자리수에서 정렬만 해주면 둘 간 정렬은 자동으로 됨. 
77. 100의 자리수로 정렬. 
78. internal sorting들 간 비교.
81. external sorting은 disk라는 external memory에서 load time과 seek time 등을 합해서 고려해야함.

==Complexity of Algorithm==
19. 통상 linear time algorithm이 quadratic time algorithm보다 효율적이다. 적은 스텝으로 표현 가능하기에.
20. n이 들어옴에 따라 패턴을 체크하자는 분석임. 점근적임.
21. 그걸 simplificate하게 만든 수식임. 차수가 낮은 것들은 높은 것들에 의해 영향이 미비하게 됨. 


==Divide and Conquer==
9. ~넘어감
10. 주어진 일 n을 다음엔 반만 함 -> n/2
12. 홀짝 나눈느 방식 다름
13. n/2은 k에 포함되는 단계임. 귀납법으로 증명 (1일 떄, 일반 k 일 때, 홀짝 일 때).
21. ~참고
22. 마지막 merge에서 n (오른쪽) +m (왼쪽) - 1 번 비교함. 2^k  = n  -> k = logn 이다 -> nlogn이 도출됨.
25. h+m-1은 나누는 순간에 비교하게 되는 횟수 (머지할 때 걸리는 시간). 전체 원소 수 n = h + m임.  
26. n-1은 n/2+n/2-1으로 유도 됨. 
31. 단계별 비교횟수는 n/2이다 (1단계는 n/2, 2단계는 n/4 .. ) -> 결국 O(n)임. n/2^k = 1이 될 때 까지 내려옴 -> 단계 k 는 logn임.
36. worst case는 피봇이 제일 끝에 있고 다른 한쪽으로 다 몰렸을 때임 -> O(n^2) 나온다.
38. 넘어감
44. monotone : 일차함수 처럼 한 방향으로만 증가하는 형태. 2^n처럼 지수가 붙어있어도 쓸 수 없다. 
50. 행렬 연산이 n^3 (for 3번) 나오는데 이걸 개선하기 위해 strassen algorithm 나옴. 
51. element대신 block 단위로 연산이 일어남.


==Divide and Conquer addition==
6. 절반 나눠서 제일 가까운 거리 조사하고 추가적으로 (p1, q3)도 확인해 줌. 
7. 이걸 재귀적으로 확인 함.
9. 주변 델타 만큼만 비교하면 됨. 가까운점 6개만 비교하면 됨
12. recurseive하게 반반 탐색이 O(logn). 


==Dynamic Programming 1==
2. divide and conquer는 top down, dp는 bottom up 방식임. 
4. (n-1 / k-1) = (n-2 / k-2) + (n-1 / k-1) 이고 (n-1 / k) = (n-2 / k-1) + (n-2 / k) 이다.
9. 다이고날 라인은 (k / k) 즉 k개 중에 k개 뽑는 것. (2 / 1) 은 (1 / 1) + (1/ 0)임. 계수를 표현한 표임. (a+b)^는 세로 (1,1,1,1, 1)이 나옴. (a+b)^2이면 (1, 2, 1)이 나옴 
10. (n/k)는 (a+b)^m 일때 a^k b^(n-k)의 계수를 구하는 거임 (a^(n-k) b^k 계수와 같음)
15. optimal value는 항상 최종 정답안에 포함됨. optimize 하는 과정에서 계속 그 값을 끌고 가니까. 

==Dynamic Programming 2==
3. 나타나는 순서가 같으면 subsequence (연속일 필요 x).
48. mismatch아면 -1 
56. local 은 초기화를 0으로. 

==Greedy ALgo==
21. 빈도수 차이로
65. principle of optimality 보장해야함. 새로운걸 넣을생각이 없으면 이전 아이템의 이득을 유지하면됨. 새로 넣으려면 W-wn을 넘어서는 안됨. 
73. 2,3 문단 넘어감


----
----


==Back Tracking==
7. DFS를 약간 수정한게 back tracking이다. 
13. 1,1은 promising node, 2,1은 갈 필요없어서 뺵 쳤으니 non promising node임.
23. 절대값 i-k는 가로길이, col(i) - col(k)는 세로 길이인데 이 둘이 같다는건 정사각형 상에서 대각에 위치한다는 뜻이니. 
25. 그 방법을 체택한 promising backtracking 방법임.
26. 총 체크 횟수를 따질땐 각 레벨에서 전체 pruned state space를 모두 조사하니 레벨이 커지는 만큼 n승하게 됨. 
27. 하나 결정될 때 다음게 위치할 수 없는 경우를 제거하면 팩토리얼 형태로 나옴. 
- 몬테카를로 알고리즘은 백트래킹과 결합하여 초기 탐색 방향을 설정하거나 확률적 가지치기를 통해 탐색 공간을 줄이는 데 유용합니다. 이를 통해 복잡한 문제를 보다 효율적으로 해결할 수 있습니다. 특히, 해의 공간이 크고 탐색 시간이 중요한 문제에서 몬테카를로 알고리즘을 활용하여 백트래킹의 성능을 개선할 수 있습니다.
36. 언급된 단계는 주로 확장(Expansion)단계에서 발생합니다. 이 단계를 더 자세히 설명하면 다음과 같습니다:
    1. **현재 노드**: 이 시점에서 트리의 현재 노드를 선택했습니다. 이 노드는 검색 공간의 특정 상태(예: 게임의 위치)를 나타냅니다.
    2. **유망한 자식 노드 생성**:
    - **유망한 자식 노드**: 현재 노드에서 지금까지의 검색을 기반으로 가장 유망한 이동이나 행동을 나타내는 자식 노드입니다.
    - **무작위 선택**: 모든 가능한 자식을 체계적으로 생성하거나 하나를 결정론적으로 선택하는 대신, 유망한 자식 중 하나를 무작위로 생성합니다. 이 무작위성은 더 넓은 검색 공간을 탐색하고 결정론적 함정을 피하는 데 도움이 됩니다.
    3. **유망한 자식 노드의 수 (mi)**: 이것은 현재 노드에서 유망한 자식 노드의 수입니다. 선택된 자식을 무작위로 생성하는 것은 이 유망한 옵션들 중에서 무작위로 선택하는 것입니다.
37. ti : 레벨 i에 있는 노드의 총 자식 노드 수입니다. mi: 레벨 i에 있는 노드 중에서 유망한(즉, 추가적으로 탐색할 가치가 있는) 자식 노드의 수입니다.
- 레벨 2 : 레벨 1에서 선택된 유망한 자식 노드(m0)의 모든 자식 노드(t1)가 탐색됩니다. 그 중에서 유망한 노드(m1)만이 다음 레벨로 확장됩니다.
- 탐색 노드 수 = 1 + t0 + m0 * t1
- 레벨 3 : 레벨 2에서 선택된 유망한 자식 노드(m0 * m1)의 모든 자식 노드(t2)가 탐색됩니다. 그 중에서 유망한 노드(m2)만이 다음 레벨로 확장됩니다.
- 탐색 노드 수 = 1 + t0 + m0 * t1 + m0 * m1 * t2

==Back Tracking 2== *16pge까지 리뷰함*
6. 앞으로의 모든 remaining + i 까지의 합한 모든 weight가 W보다 작아도 non promising.
7. W보단 커야 promising 하다 할 수 있음.
14. W는 인접행렬. 1이면 connected, 0이면 disconnected.
24. 내가 얻을 수 있는 '계산상'의 최고이득을 bound로 놓는다. 이걸 기준으로 promising 여부를 따짐. 
25. 시그마(i+1 ~ k-1)에서 k는 weight를 초과하는 아이템임. 

==Branch and Bound==
20. 계산오류 있는 듯.
30. bound는 미래 이득까지 같이 더함. 초과되면 아이템을 쪼갬. total weight는 쪼개서 넣지 않음.
38. 맨 마지막 노드 4 중복 오타
40. 각 row에서 0이 아닌 최소 값들을 더한게 가장 minimal한 값이 된다 (그 루트가 실제로 존재하는지는 모르지만 이것 보다 최소가 되는 경로는 없음). 그게 low bound가 됨.
42. 부터 계산은 교재 참조로 넘어감

==A Star Algorithm==
11. g(n) : start ~ n 까지의 거리비용. h(n) : n ~ 목표까지의 추정된 거리비용.
12. 그리드그래프임. 파란색 : 장애물. 빨간색 : 목표. 
16. h값이 0인 Astar가 다익스트라이다. 
19. 다익은 탐색공간이 너무 크다. 
20. 추정잔여거리 + 실제거리 작은 값을 선택.
23. 7이 오른쪽, 6이 밑, 5가 왼쪽으로 이동하는 경우가 뎁스가 1인 상태임. 파이널 스테이트와 비교해서 위치 마다 정답이 다르면 감정 주면서 평가함.
24. h는 미스매치 점수임.  g는 뎁스(변화량). h+g 작은 케이스를 선택해서 반복. 이미 자기 자리를 잘 잡은 애는 케이스 옮기는 케이스를 고려하지 않는듯 (이미 closed list에 들어가 있으니).  
29. D 한 다음엔 D보다 이전에 게산한 A가 더 작으니(16) A에 대해 E를 구함.
30. F를 구하고 나면 F가 B나 D보다 작으므로 계속 G를 구함. 이때 B는 이밈 closed list에 들어가있으니 계산할 필요 없음. 그래서 AEFG가 최종 경로가 됨. (D의 경우 B와 F 갈 수 없으니 답 아님). 
31. BDF나 BDC에서 G로 못가는 이유는 이미 앞에서 AEFG로 G를 closed list에 넣었기 때문인듯.
32. (h, g, f)에 대해 a(0, 21, 21). b(9, 14, 23). c(4, 18, 22). d(7, 18, 25). 가장 작은 c를 선택. e(21, 5, 26). f(16, 8, 24). 이제 가장 작은 b 선택. 이때 e는 이미 업데이트 된 상태인데 한 번 더 해봄. e(20, 5, 25) 그래서 e는 저게 더 작으니 저걸로 업데이트. 이제 f에 대해 해보고 ~. 최종적으로 abez가 shortest path가 되는 듯.  

 ==String Matching==
 12. 시그마는 오토마타를 구축하는 시간 (알파벳 문자 수).
15. A[i] * d^(m-1) + A[i+1] * d^(m-2) ... + A[i+m-1] * d^0 를 묶어냄. 
16. 356에 a를 뺴고 c를 더해서 1782를 찾아냄. 
23. 한 칸씩 뒤로 보내는게 아니라 접두부와 접미부가 일치하는 부분 만큼 그 위치로 옮김. 
28. a끼리 매칭됐으면 더 이상 움직이지 않고 다음것들과 비교함. 
29. w에서 미스매칭 일어나면 a를 쭉밀어서 밑에 리스트 상으로 까지 밀고 비교한다는 뜻임. 

==String Matching 2==
4. suffix array를 binary search 형태로 찾는 방법이 있다. 
5. n이 길면 시간오래걸리니
6. 통으로 비교하는게 아니라 첫 글자 기준으로 비교함. a로 시작하면 다 rank 1.
7. 이제 두 글자로 비교함.  ana와 anana 간의 순서는 비교하지 않고 그냥 같은 그룹으로 묶는다는 의미임. 이건 차후에 더 나누어야함을 의미함. 
8. 3글자가 아니라 2^n이니 4글자를 봄. 
11. 뒷 네글자 ATCA는 트리에서 suffix 9를 가짐을 확인할 수 있음. 

==Geometry Algorithm==
27. p1프라임은 p0->p1 선상의 벡터임. po-p1 선분은 p2 기준으로 clockwise 방향에 있음. p1프 x p2프와 p2프 x p1프는 다른듯. 
52. 넘어감
58. 보르누이 부터는 개념만 알기

==Geometry Algorithm2==
17. 저 영역에 있는 어떤 점(1번)이 교차되는 부분이다. 
21. 그리드 상 사각형에 포함된 영역만 탐색함.
25. 우선 점들의 x 좌표상 가운데 있는 값을 기준으로 분할함. 그 후 y축 값들 중 중간값으로 분할함. 이걸 번갈아가면 영역을 양분함. 
31. 들어오는 순서대로 2d tree 구축
- x축양분 후 y축 양분하면 다음과 같음
                 (9,1)
          (2, 7)               (17, 15)
       (3,6)   (6,12)    (10,19)  (13,15)

----

==Genetric Algorithm==
29. 섞는 방법.
32. 0인 부분은 바꿈.
36. 랜덤하게 바꿈
39. 돌연변이
42. 윗그림 잘못, 박스 한 칸 앞으로 옮겨야함. 밑그림 69.4와 67.5 박스
45. 목표에 빨리 도달할 수 있도록 역할을 함. 냅색에서 fitness function은 가방안에 들어있는 물건의 토탈 가치이다. 
46. generational : 부모 세대 모두를 바꾸는 방식
52. fx가 점점 좋아지는 방향이 될 것.
54. fitness funciton으로 1이 몇개 있는지 체크하는 것으로 삼음. 
59. 6개중에 4개의 돌연변이 발생. 2개는 2개 바꾸고 2개는 1개, 나머지 2개는 변화 없음. 
65. 섞는 규칙은 임의로 정한거임 패런츠 중에 한 영역은 그대로 유지하는거임. 




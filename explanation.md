
- 유형 순서는 필요에 따라 변경 가능

- ==재귀 (2)==
  - 2447 : 별 찍기 - 10
    - size가 1이 될 때까지 3X3 크기로 계속해서 분할
    - 최소 단위(1)로 분할했으면 별 저장
    - 나는 재귀 대신 for문으로 풂
  - 1074 : Z
    - 배열을 완전하게 채우려는데 지나치게 몰두 하지 말기
    - 필요한 정보만 뽑아서 취할 수 있도록 거시적(대충)으로 보기

- ==백트래킹 (8)== *보완필요*
  - 정리
    - 기본적으로 dfs 앞 뒤로 true, false 혹은 +/-1 로 감싼다.
    - 재귀 방식이나 종료조건들을 두어서 유망함을 따진다
    - 재귀 depth를 체크하고 for문의 초기값을 idx등으로 둬서 시간 초과를 막는다
  - 15649 : N과 M (1) *BackTracking 대표문제*
    - visit 함수로 dfs 앞뒤를 true와 false로 감싼다
  - 9663 : N-Queen
    - stranger's LAB은 dfs 들어가기 전 조건을 걸어 검사하기에 true/false가 필요없다
    - barking dog은 기존 true/dfs/false 형태임
  - 2580 : 스도쿠
    - 구조잡기 좋은 문제
  - 14888 : 연산자 끼워넣기 *좋음*
    - 종료 조건을 연산자가 0일때가 아니라 idx가 N일때로 해야함
    - for문을 수열로 잡는게 아니라 연산자 4개로 잡아야 함
  - 14889 : 스타트와 링크
    - ArrayList를 쓰지 말고, if (recruited(i) == true && recruited(j) == true) 이 조건으로 검사해서 배열에서 바로 뽑아 쓰면 됨
    - idx를 써도 되는 이유가 만약 idx 이전의 값을 조사해야할 필요가 있었다면 이전 시퀀스때 했을거임. 그러니 idx부터 조사하면 됨. 만약 0부터 조사하면 시간초과 뜸.
    - 즉 idx를 사용하는 이유는 이전에 선택된 멤버의 이후부터 탐색을 시작해야 중복 없이 올바른 조합을 생성할 수 있기 때문입니다.

- ==동적계획법1 (16)==
  - 1912 : 연속합
    - (이전 dp + 현재 arr값) 과 현재 arr값 중 큰 것을 dp에 저장
    - 그 후 dp 배열에서 최대값을 추출함
    - 즉 이전값 10에 현재 값 -4를 포함시킨 값인 10 + (-4) = 6이 자기 자신인 -4를 단순히 선택하는 것 보다 크기에 6을 선택하는 것임. 만약 단순히 자기 자신인 현재 arr(i)값이 더 크면 그걸 선택해야 함.
  - 1149 : RGB거리 *dp 대표문제*
    - 입력 받은 배열 처음부터 누적해버리는 방식을 이용함
    - 1부터 N-1까지 각 i별 i-1의 서로 다른 색상 중 최솟값을 누적하여 더한다.
    - 만약 현재 RGB가 1, 100, 103이고 G인 100을 선택하고 그 다음 집이 1, 103, 200 그 다음 집이 100, 1, 103일때 현재~다음~그다음의 최소값은 G->R->G이다. G->B->G를 검사하지 않는걸 걱정하지 않아도 되는 이유가 어떤 루트든 결국 G에 도달하면 그 다음시퀀스에 대해 R과 B는 항상 열려있기에 문제될게 없다. 그렇기에 GBG는 애초에 GRG보다 큰 값이라 min으로 조사해버리면 거를 수 있다.
  - 1932 : 정수 삼각형 *다른 방식으로 해결함*
    - 나는 밑에서부터 누적해서 더해 채우는 방식으로 풂
    - Math.max(arr[i][j], arr[i][j + 1]);로 비교해서 큰 놈을 위쪽 row에 누적해서 더하면 결국 arr(1,1)이 최대값이 됨
  - 2579 : 계단 오르기
    - n-3을 조사해야함. n-1을 메모이제이션 해봤자 이게 이전 계단을 밟은 상태인지 알수가 없기 떄문임. 즉 더 폭 넓은 점화식을 설정해줘야함
    - 이러면 계단 3칸을 따로 변수 둬서 조사할 필요가 없어지니 좋음
  - 10844 : 쉬운 계단 수
    - dp 배열을 어떻게 잡을지 잘 정해야함
  - 2156 : 포도주 시식
    - 여전히 범위 크기 지정하는거 고려해야하고
    - dp(x) = y에서 x를 포함하는건지 아닌건지, 설정에 따라
    - 마지막에 dp 전체를 돌면서 최대값을 뽑아줘야할  도 있음.
    - 엣지 케이스 n = 1 같은거 런타임 에러 안뜨게 잘 설정해야함
  - 11053 : 가장 긴 증가하는 부분 수열 *LIS 대표문제*
    - 어렵게 생각하지 말기
  - 11054 : 가장 긴 바이토닉 부분 수열
    - 꼭 최대값이 바이토닉의 기준점일 근거 없음
    - 구현 방식에 따라 시간 차이 많이 남
  - 2565 : 전깃줄
    - 배열 사이즈, 차원 잘 설정하기
    - LCS for문 안에서 맥스값 찾는것과 dp 다 채운 후 나중에 맥스값 찾는것은 차이가 있음을 인지해라
  - 9251 : LCS *LCS 대표 문제*
    - 행과 열 잘 셋팅하고
    - (1,2)에서 매칭이 일어났다는건 (0,2)에서 +1 됐다고 해석할 수 있다.
  - 12865 : 평범한 배낭 *Knapsack 대표문제*
    - dp 차원 설정 잘하기
    - i번째 물건을 담을때, '그 물건을 담기 이전 상황 + 현 물건 가치'로 셋팅한다

- ==누적합 (6)==
  - 2559 : 수열
    - for문 조건 식에서 엣지 범위 (포함하고 안하고) 잘 설정하기
  - 16139 : 인간-컴퓨터 상호작용
    - row보다 column을 길게 잡아야 유리하다
    - for문 안에서 bw.write()하고 그 밖에서 bw.flush()해야 시간초과 안 걸린다
  - 10986 : 나머지 합
    - [a, b] = [1,b] - [1, a-1]
    - sum(b) % M - sum(a-1) % M == 0
    - sum(b) % M == sum(a-1) % M
    - 나머지가 같은 두 인덱스를 뽑는 경우의 수로 조합을 사용함
    - 이차원으로 하면 시간초과 or 메모리부족
  - 25682 : 체스판 다시 칠하기 2
    - 좌상단이 흑일때, 백일때 두 케이스로 2차원 배열의 누적합을 구한다.
    - 이떄 dp(i, j)는 (i,j)까지 바꿔야하는 개수를 저장하는 형태임
    - 흑일때와 백일때 두 케이스를 만들고 난 후 각 케이스에 대해 K x K로 컷팅해서 구해줌
    - for (int i = 1; i <= N - K + 1; i++) 로 사이즈 NxN보드에 대해 K x K로 컷팅
    - 모든 가능한 체스판 중 최소값이 result에 저장됩니다.

- ==그리디 (5)==
  - 1931 : 회의실배정 *Greedy 대표문제*
    - 하나의 활동을 선택하면 나머지 겹치지 않는 활동에 대해서 독립적이다 -> 탐욕 선택이 이후의 결과에 영향을 미치지 않는다
  - 1541 : 잃어버린 괄호
    - -(a+b) 의 꼴로 괄호를 쳐줘야한다. 구현 방법은 Strangers Lab의 방법이 더 간단함
    - -(a+b)가 많으면 많을수록 무조건 좋은거니 즉 이 행위 자체가 독립적이니 그리디가 가능한거임
  - 13305 : 주유소
    - i부터 조사하는데 다음 도시가 지금 도시보다 싸면 거기까지만 간다. 만약 다음 도시가 지금 도시 가격보다 크면 무시하고 지금 내 가격 유지한다.
    - 범위 잘 보고 long으로 고쳐야 맞음

- ==분할정복 (9)==
  - 2630 : 색종이 만들기 *분할정복 대표문제*
    - 이중 for문 탐색 중 더러운 색깔 발견하면 split_conquer 하고 return으로 종료도 해줘야 한다.
    - 더러운 놈이 끼여있으면 무조건 4등분으로 분할해야하기 떄문에 더 탐색을 안해도 되니까.
    - 보드 전체가 1이거나 0일때의 케이스도 따로 취급해줘야한다.
    - Stranger lab 구현 방법이 더 간단함 (풀스캔 결과를 불리안으로 체크함)
  - 1629 : 곱셈 *분할정복 대표문제, 다시풀기*
    - (A x B) mod C = (A mod C x B mod C) mod C
    - 10^11 = 10^5 x 10^5 x 10^1이다 후자의 10^5는 중복해서 해줄 필요가 없다. 즉 반으로 나눠서 한번만 탐색시키도록 한다.
    - 홀수일때, 짝수일때 구분해줘야한다
  - 11401 : 이항 계수 3
    - 페르마 소정리
    - a^p mod p = a mod p -> a^(p-1) = 1 mod p
    - a x a^(p-2) = 1 mod p
  - 2740 : 행렬 곱셈
    - 문제 안 좋음. 특정 수학 원리에 의존적임
    - 그냥 행렬곱 구현해도 통과됨
  - 10830 : 행렬 제곱
    - 1629번 + 2740번

- ==이분탐색 (7)==
  - 1920 : 수 찾기 *Binary Search 대표문제*
    - 인덱스 시작을 1부터 할거면 소팅할때
    - Arrays.sort(arr, 1, n + 1); 써야함
  - 10816 : 숫자 카드 2 *다시*
    - 10000000 배열 음양용으로 두 개 준비해서 소팅없이 단순하게 풀어도 풀리긴함
    - 1920번에서 찾은 mid값 기준 좌우로 범위 스캔하는건 다 시간초과 걸렸음
      - start -> mid 가면서 일치하는 값을 cnt += mid - i로 해도 시간초과
      - mid -> start 가면서 arr(i)값 다르면 break해도 시간초과
    - Stranger's LAB
      - lower bound : 하한은 찾고자 하는 특정 값 '이상'인 '첫 위치'를 반환
      - upper bound : 상한은 찾고자 하는 특정 값을 '초과'하는 '첫 위치'를 반환
      - 중복 원소에 대한 길이 = upper bound - lower bound (low <= idx < high)
        - 만약 원소가 존재하지 않는다면 상한과 하한 모두 같은 인덱스를 가리키고 있을 것이기에 0이 되므로 이 또한 존재하지 않는 원소를 찾으려 할 경우의 예외 또한 안전
        - 즉 low<=idx 이기에 key <= arr(mid)로 lower bound 설정
        - idx < high 이기에 key < arr(mid)로 upper bound 설정
  - 1654 : 랜선 자르기
    - parametric search
    - 바킹독 피셜 과감하게 재껴도 된다
    - mid길이로 잘랐을 때의 개수가 만들고자 하는 랜선의 개수보다 작다면
    * 자르고자 하는 길이를 줄이기 위해 최대 길이를 줄인다.
    * 그 외에는 자르고자 하는 길이를 늘려야 하므로 최소 길이를 늘린다.
    * 특정 인덱스를 구하는게 아닌 길이를 구해야하기에 정렬도 필요 없다
    - mid = (max + min) / 2; 에서 max가 길이가 1일때의 케이스 처리해줘야함
  - 2805 : 나무 자르기
    - 정답 맞췄고 풀다 보니 max값을 감소시키는 꼴이 됐긴함
    - 상관없음.
    - 생각보다 쉽네 손으로 써서 적당히 해보면 금방 나옴
  - 2110 : 공유기 설치
    - 결국 최소 거리가 최대가 되기 위해서는 첫 번째 집은 설치가 되어있어야 함
    - 첫 번째 집에서 앞부분에 빈공간이 공간이 남는만큼 결국 최소거리가 점점 줄어들게되겠죠
    - *입력 10억짜리면 대부분 이분탐색이다*
    - 가장 인접한 두 공유기 사이 거리를 mid라고 하고 공유기를 설치하는 방법으로 푼다
    - mid 거리에 대해 설치 가능한 공유기 개수가 M 개수에 못미치면 거리를 좁혀야하니 hi를 mid 만큼 줄인다.
    - 설치 가능한 공유기 개수가 M 개수보다 크거나 같으면 거리를 벌리면서 최소 거리가 가질 수 있는 최대거리를 찾기 위해 low = mid + 1 해주면서 체크한다.
    - Upper Bound는 탐색 값을 초과하는 첫 번째 값을 가리키므로, low에서 1을 빼준 값이 조건식 만족하는 최대값이 됨
    - [7. 이분 탐색 - 문제](https://www.youtube.com/watch?v=Wbhwlf4stfY)
  - 1300 (k번쨰 수), 12015(가장 긴 증가하는 부분 수열 2) 난이도 이슈로 스킵함

- ==우선순위 큐 (3)==
  - 쉬워서 다 풂
  - int compare(Integer o1, Integer o2)로 오버라이딩 하는거 알아보기
  - pq : 우선순위가 가장 높은 요소(가장 작은 값)이 항상 루트에 오도록 유지한다
  - 13975 : 파일 합치기 3
    - pq의 개념으로 푼다. 연속의 조건이 없기에 가장 작은 얘들 두 개를 합쳐서 add 해주고 끝날때 까지 반복하면 된다.

- ==동적계획법2 (6)==
  - 11066 : 파일 합치기
    - "두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합침"
      - 이 이유 떄문에 pq를 쓸 수 가 없음.
      - pq는 연속성을 보장 받지 못하기때문
      - 즉 3개를 묶을땐 길이 내에서 2개씩 묶어 그 위치를 이동하면서 최소값을 찾아낸다. 코드 주석 참고
      - 즉 합치기전에 먼저 여러개의 부분으로 쪼개서 최적의 조합을 찾은 후 마지막에 한 번 더 합쳐야합니다.
      - 어디서 나누는지에 따라 비용이 달라지므로 최적의 조합을 찾아야함
    - 점화식의 핵심은 i번 부터 j 까지 합한 최솟값이라 정의하는 거임
      - i파일이 j파일과 합쳤을 경우 같은 독립적인 정의 방식은 아무 쓸모가 없다.
  - 11049 : 행렬 곱셈 순서
    - 위에 문제와 유사함
    - process(i)(0) * process(j)(1) * process(i+k)(1));
  - 1529 : 내리막길 *좋음*
    - dp(i, j) = (i,j)에서 끝점으로 갈 수 있는 방법의 수
    - DFS를 이용해서 탐색을 하되 이미 탐색해서 경로의 개수가 파악된 지점을 또 파악하면 비효율적이니 dp를 써야함
    - (1,1) 시작해서 어쩌다 (3,3)에 도달했을때 (3,3)->(m,n)의 경로 개수가 저장되어있다면 중복해서 셀 필요 없다
    - 무조건 높->낮으로 가야하니 싸이클 고려 x
    - visited 대신 dp에 -1 넣고 비교
    - 최소값을 찾는 것이 아니라 가능한 경로를 누적해서 더하는 문제이므로 Math.min()을 사용할 필요가 없습니다.
    - 3 3  / 6 5 4 / 5 3 3 / 7 2 1 로 케이스 생각하고 dfs 경로 보면 이해됨
      - dp(1)(2) 는 오른쪽에서 오는 얘 1과 밑에서 오는 얘 1을 합친 2가 됨
  - 2629 : 양팔저울
    - bool dp(idx)(weight)로 잡고 추 하나 단독 무게, 현재 추 무게에 새로운 추 더했을때 무게, 현재 추 무게에 새로운 추 뺐을때 무게(반대쪽 저울에 추를 올린다는 개념)를 true로 해준다
    - 즉 여러개의 추를 합침으로 새로운 무게를 잴 수 있고, 여러 개의 추를 뺌으로써 새로운 무게를 잴 수 있다 (반대쪽 저울에 추를 올린다는 개념)
  - 2293 : 동전 1
    - dp(i) = j 에서 i는 금액, j는 i원을 만드는데 가능한 경우의 수
    - dp(k) = dp(k) + dp(k -  arr(idx))
    - 10원을 만들 수 있는 경우의 수 를 알면, 15원을 만들 수 있는 경우의 수도 쉽게 계산할 수 있으니 dp 문제이다
    - 중복 순열이 아닌 조합이므로 1차원 dp 배열을 사용해 푼다
    - 만약 j = arr(i) 가 5라면 dp(5) += dp(5-5) 인 dp(0) 즉 0원을 만드는 방법인 아무 동전도 사용하지 않는 경우 1만 더해지게 되고
    - 그 다음 j++되서 j가 6이면 dp(6) += dp(6-5) 인 dp(1) 을 더하게 된다 즉 dp(6) 은 동전5를 한 번 쓴 뒤 dp(1)인 1을 만드는 방법의 루트를 더한거니까

- ==스택 2 (5)==
  - 9935 : 문자열 폭발
    - !stack.isEmpty() && !bombstack.isEmpty() 걸어준 뒤
    - stack과 bombstack의 peek이 일치하는지 점검해야 안 터진다
    - 즉 abc라는 문자열을 스택에 차례로 점검해서 넣으려 할 때 c는 bc라는 폭발물의 스택 끝 부분인 'c'에서 체크가 된다.
    - 그래서 c 부분 부터 스택을 뺴내가며 bc가 일치하는지 found 플래그로 체크하고
    - 체크가 끝나면 recover로 복구 시켜준다. 만약 found라면 폭발물이 일치해서 뺸거니까 복구 해주면 안된다. 그래서 바로 break 이고 found가 false이면 폭발물로 오해하면서 stack을 점검한거니 다시 복구 해줘야하는거다.
    - 참고 코드는 스택의 크기가 폭탄 문자열의 길이와 같아지면 탐색 시작. count만 둬서 일치하면 증가시키고 점검 이후 count가 폭발물 크기와 동일하면 그 만큼 pop 해주는 방식을 했음. 즉 복구의 행위를 할 필요가 없게 구현함
  - 17298 오큰수
    - 인덱스를 이용해서 따짐
    - 주석 읽기

- ==그래프와 순회 (16)==
  - 24479 : 알고리즘 수업 - 깊이 우선 탐색 *dfs 프로토타입*
    - 이중 리스트 그래프와 dfs 재귀 사용
    - graph는 0은 더미 주고 1~5까지 사용하지만
    - graph.get(vertex).get(i)에서 i는 0번 부터 그 사이즈 만큼 쓰는 거 조심
  - 24480 : 알고리즘 수업 - 깊이 우선 탐색 2
    - Collections.sort(graph.get(i), Collections.reverseOrder());
  - 24444 : 알고리즘 수업 - 너비 우선 탐색 1 *bfs 프로토타입*
    - 이중 리스트 그래프와 bfs 큐 사용
  - 24445 : 알고리즘 수업 - 너비 우선 탐색 2
    - Collections.sort(graph.get(i), Collections.reverseOrder());
  - 2606 : 바이러스
    - 소팅할 필요 없이 count만 세면 된다
    - 24479랑 같은데 1번 외의 감염 개수니까 1만 뺴주면 되고
  - 1260 : DFS와 BFS *dfs, bfs ArrayList<<>> 프로토 타입*
    - 24479, 24444는 각 노드 인덱스별 순서를 출력하는 거였고
    - 이 문제는 그냥 방문 순서를 list에 담아서 출력했음
    - 만약 그래프가 아니라 2차원 배열로 bfs 할거면
      - arr(start)(i)로 start에 엮인 i 인덱스들 다 조사한다
      - [[백준알고리즘-JAVA]1260번 풀이(DFS와 BFS) - 초보도 이해하는 풀이](https://infodon.tistory.com/96)
  - 2667 : 단지번호붙이기
    - dfs를 4방향에 대해 수행하면 됨
    - 4방향 더할때 rX의 i를 더해야지 그냥 i를 더하는 불상사를 만들지 말것
  - 1012 : 유기농 배추
    - int nr = curr + rY(pos);
    - 좌표 여러개라 헷갈리니까 뻘짓 하지 말기
    - bfs로 할거면
      - [17171771 :: 백준 1012번 java 유기농배추 [dfs,bfs]](https://1-7171771.tistory.com/59)
      - qu.add(new int[] { x, y });
      - x = qu.peek()[0];
      - y = qu.peek()[1];
  - 2178 : 미로 탐색 *bfs 좋음*
    - 이건 정점들간 간선들로 연결된 문제가 아니라
    - 단순하게 미로가 시각적으로 주어진 꼴인거임.
    - dfs는 모든 경로를 다 가는거라 최소거리가 안나옴
    - 그렇다고 백트랙킹으로 dfs 앞뒤로 true false로 묶어서 풀면 시간초과 걸림
    - bfs로 해결했고 특히 나는 curcnt로 카운팅하면서 종료 위치에 도달하면 그걸 반환하는 방식을 선택했는데 다른 사람은 입력받은 이차원 보드 자체를 1씩 더해가면서 마지막 위치의 원소값을 리턴했음
    - 갈 수 있는 길이면 무조건 1씩 전진하기에 겹칠 걱정을 할 필요가 없다. 애초에 겹치는건 필터링하지만서도 어느 루트로 가든 1씩 증가이기에 결국 그 자리는 항상 최소 거리가 되는거다.  1씩증가 + 겹침 방지 = 최소거리
  - 1697 : 숨바꼭질
    - x지점을 1이라 잡으면 x-1, x+1, 2x는 +1한 2가 되고 각 3자리를 큐에 넣고 동일한 행위를 반복해준다. 만약 방문한 점은 진행할 필요 없으니 필터링 해준다
    - dp로 풀리지 않을까 고민을 많이했음. dp(x) = y는 x지점에서 종료지점 m까지 가는 최소 시간 y초.
    - 그런데 dp(m)=0, dp(m-1)=1이므로 뒤에서 시작해서 앞으로 채워나가야하는데
    - dp(m-2) = dp(m-1)+1 or dp(m-3)+1 or dp(m/2)+1 의 경우 dp(m-3)을 내가 알 방법이 없다. 당연히 m/2도 알 방법이 없음 채우기전이라.
    - dp도 가능함 [백준 1697번 숨바꼭질 DP (Java, Kotlin)](https://velog.io/@lifeisbeautiful/%EB%B0%B1%EC%A4%80-1697%EB%B2%88-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88-DP-Java-Kotlin)
    - dp[m-1] = 1, dp[m-2] = 2로 쭉 초기화 해주고.
    - +1 후 점프, -1 후 점프, 제자리 점프 중 최소값 min 업데이트
    - 그리고 distance[i] = Math.min(min,  distance[i-1]+1); 이것 까지해줘야함
  - 7562 : 나이트의 이동
    - 2178 미로 탐색과 똑같음
  - 7576 : 토마토
    - 시작지점 여러개라도 다 큐에 넣고 똑같이 돌리면 된다
    - 엣지케이스 잘 걸러주기
  - 7569 : 토마토
    - 3차원 배열을 3중 for문으로 받을때 row, column, height 배열로 받고 싶으면
    - height가 for문의 최외각에 위치해야함, 혹은 height, row, column 순으로 배열 정의해도 됨
    - 2차원 평면에서 +m한 거리를 비교하고자 했으나 4방향을 조사할때 서로 다른 층에 위치해 검사하면 안되는 케이스를 거르기 번거롭다는걸 깨닫고 3차원으로 풀었음
  - 16928 : 뱀과 사다리 게임
    - 사다리나 뱀의 해쉬맵을 찾으면 바로 이동될 경로를 queue에 넣을 원소로 셋팅 해줘야한다.
    - 둘을 구분해서 따로따로 넣어주면 에러뜬다.
    - 즉 사다리(10->80)이고 주사위 굴린건 반영한 nxpos가 10이면
  - 2206 : 벽 부수고 이동하기 (골3)
    - if (visited(ny)(nx) <= p.drill)
    - 현재 (ny, nx) 좌표에 도달한 적이 있는데, 그때 사용한 벽 부수기 횟수가 현재 경로에서의 벽 부수기 횟수 p.drill보다 작거나 같다면 continue.
    - 즉 이미 더 적은 횟수로 (ny, nx)에 도달했기 때문에,  현재 경로는 더 많은 벽을 부수었거나 같으므로, 더 나은 경로가 아닙니다.
    - visited를 3차원 배열로 푸는 방법이 일반적. 즉 벽을 부순 케이스들은 벽을 부순 여부가 true인 얘들로 관리, 아닌 겨웅 false인 얘들로 관리
      - `visited[x][y][0]`는 해당 좌표에 벽을 부수지 않고 도달했음을 표시하고
      - `visited[x][y][1]`은 벽을 부순 상태로 도달했음을 표시합니다.
      - 따라서 큐에 같이 들어가더라도, 각 원소는 자신의 상태에 따라 처리되고, 방문 여부 체크 시에도  상태별로 따로 관리되므로 섞여도 혼동 없이 올바른 경로 탐색이 가능합니다.
  - 1707 : 이분 그래프
    - 시작 노드가 하나가 아닐 수 있음. 끊겨 있을 수 있으니 color 배열에서 아직 초기화 안된 파트들을 큐에 넣고 다 돌려줘야 함

==최단경로 (7)==
- 미확인 도착지 골2
- 1753 : 최단경로 *다익스트라 프로토타입*
  - 정석은 방문 여부를 check하는 배열을 따로 선언해주지만
    - 난 if (curWeight > dist(curVertex)) continue; 이걸로 필터링했음
  - PriorityQueue< Node> pq = new PriorityQueue<>((o1, o2) -> o1.weight - o2.weight); 해주거나
  - 그냥 pq할거면 compareTo 정의 해줘야함
  - 갱신 해줬을때 그 노드를 pq에 넣음
- 1504 : 특정한 최단 경로
  - pass1과 pass2 사이 거리도 다익을 해줘야 한다.
  - pass1과 pass2 사이 간선이 있는지만 체크했었는데 훨씬 더 복잡한 반레가 많다.
  - 즉 1~pass1 + pass1과2의 간선 + pass2~v 는 틀린 식이다.
  - 매번 더할 dis() INF보다 큰지 확인하고 크다면 INF를 더해줘야한다. 그래야 런타임 에러 안 뜸 (오버플로우).
  - pass1과 pass2 케이스 구분할때 인자 잘 보기 (시간 존나 날림)
- 13549 : 숨바꼭질 3
  - 어떤 행위를 먼저 해줘야할지 순서가 중요
  - 가중치가 동일하지 않은 정점을 이동하기 때문에 Q에 넣는 순서를? x2?->?-1?->?1?순서로 했기에 단순 방문처리(True/False)로도 풀 수 있었다
- 11657 : 타임머신
  - 


==투포인터 (5)==
- 소수의 연속합 골3, 냅색문제 골1


==동적계획법과 최단거리 역추적 (9)==
- 가장 긴 증가하는 부분 수열 5 플래5, 경찰차 플래4, 최소비용 구하기 2 골3, 플로이드 2 골2


==트리 (7)==
- 트리의 지름 1 골2, 트리의 순회2 골2,


==최소 신장 트리 (6)==
- 별자리 만들기 골3, 우주신과의 교감 골3, 다리 만들기 2 골1


==트리에서의 동적 계획법 (4)==
- 트리의 독립집합 골1, 사회망 서비스 골3, 우수 마을 골2


==동적계획법3 (6)==
- 할 일 정하기 1 골1, 외판원 순회 골1, 박성원 플래5, 색상황 골3


==??? 유니온 파인드 (4)==
- 친구 네트워크 골2,



- kmp, trie, 위상정렬은 투머치라는 의견
- 비트마스킹도 적당히만 알면됨
- 요즘은 문자열 파싱 자체를 하는 식으로 구현력을 많이 물어봄


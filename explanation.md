
- 유형 순서는 필요에 따라 변경 가능

==재귀==
- 2447 : 별 찍기 - 10
    - size가 1이 될 때까지 3X3 크기로 계속해서 분할
    - 최소 단위(1)로 분할했으면 별 저장
    - 나는 재귀 대신 for문으로 풂
- 1074 : Z
    - 배열을 완전하게 채우려는데 지나치게 몰두 하지 말기
    - 필요한 정보만 뽑아서 취할 수 있도록 거시적(대충)으로 보기

==백트래킹 (8)== *보완필요*
- 정리
    - 기본적으로 dfs 앞 뒤로 true, false 혹은 +/-1 로 감싼다.
    - 재귀 방식이나 종료조건들을 두어서 유망함을 따진다
    - 재귀 depth를 체크하고 for문의 초기값을 idx등으로 둬서 시간 초과를 막는다
- 15649 : N과 M (1) *BackTracking 대표문제*
    - visit 함수로 dfs 앞뒤를 true와 false로 감싼다
- 9663 : N-Queen
    - stranger's LAB은 dfs 들어가기 전 조건을 걸어 검사하기에 true/false가 필요없다
    - barking dog은 기존 true/dfs/false 형태임
- 2580 : 스도쿠
    - 구조잡기 좋은 문제
- 14888 : 연산자 끼워넣기 *좋음*
    - 종료 조건을 연산자가 0일때가 아니라 idx가 N일때로 해야함
    - for문을 수열로 잡는게 아니라 연산자 4개로 잡아야 함
- 14889 : 스타트와 링크
    - ArrayList를 쓰지 말고, if (recruited(i) == true && recruited(j) == true) 이 조건으로 검사해서 배열에서 바로 뽑아 쓰면 됨
    - idx를 써도 되는 이유가 만약 idx 이전의 값을 조사해야할 필요가 있었다면 이전 시퀀스때 했을거임. 그러니 idx부터 조사하면 됨. 만약 0부터 조사하면 시간초과 뜸.
    - 즉 idx를 사용하는 이유는 이전에 선택된 멤버의 이후부터 탐색을 시작해야 중복 없이 올바른 조합을 생성할 수 있기 때문입니다.

==동적계획법1 (16)==
- 1912 : 연속합
    - (이전 dp + 현재 arr값) 과 현재 arr값 중 큰 것을 dp에 저장
    - 그 후 dp 배열에서 최대값을 추출함
    - 즉 이전값 10에 현재 값 -4를 포함시킨 값인 10 + (-4) = 6이 자기 자신인 -4를 단순히 선택하는 것 보다 크기에 6을 선택하는 것임. 만약 단순히 자기 자신인 현재 arr(i)값이 더 크면 그걸 선택해야 함.
- 1149 : RGB거리 *dp 대표문제*
    - 입력 받은 배열 처음부터 누적해버리는 방식을 이용함
    - 1부터 N-1까지 각 i별 i-1의 서로 다른 색상 중 최솟값을 누적하여 더한다.
    - 만약 현재 RGB가 1, 100, 103이고 G인 100을 선택하고 그 다음 집이 1, 103, 200 그 다음 집이 100, 1, 103일때 현재~다음~그다음의 최소값은 G->R->G이다. G->B->G를 검사하지 않는걸 걱정하지 않아도 되는 이유가 어떤 루트든 결국 G에 도달하면 그 다음시퀀스에 대해 R과 B는 항상 열려있기에 문제될게 없다. 그렇기에 GBG는 애초에 GRG보다 큰 값이라 min으로 조사해버리면 거를 수 있다.
- 1932 : 정수 삼각형 *다른 방식으로 해결함*
    - 나는 밑에서부터 누적해서 더해 채우는 방식으로 풂
    - Math.max(arr[i][j], arr[i][j + 1]);로 비교해서 큰 놈을 위쪽 row에 누적해서 더하면 결국 arr(1,1)이 최대값이 됨
- 2579 : 계단 오르기
    - n-3을 조사해야함. n-1을 메모이제이션 해봤자 이게 이전 계단을 밟은 상태인지 알수가 없기 떄문임. 즉 더 폭 넓은 점화식을 설정해줘야함
    - 이러면 계단 3칸을 따로 변수 둬서 조사할 필요가 없어지니 좋음
- 10844 : 쉬운 계단 수
    - dp 배열을 어떻게 잡을지 잘 정해야함
- 2156 : 포도주 시식
    - 여전히 범위 크기 지정하는거 고려해야하고
    - dp(x) = y에서 x를 포함하는건지 아닌건지, 설정에 따라
    - 마지막에 dp 전체를 돌면서 최대값을 뽑아줘야할  도 있음.
    - 엣지 케이스 n = 1 같은거 런타임 에러 안뜨게 잘 설정해야함
- 11053 : 가장 긴 증가하는 부분 수열 *LIS 대표문제*
    - 어렵게 생각하지 말기
- 11054 : 가장 긴 바이토닉 부분 수열
    - 꼭 최대값이 바이토닉의 기준점일 근거 없음
    - 구현 방식에 따라 시간 차이 많이 남
- 2565 : 전깃줄
    - 배열 사이즈, 차원 잘 설정하기
    - LCS for문 안에서 맥스값 찾는것과 dp 다 채운 후 나중에 맥스값 찾는것은 차이가 있음을 인지해라
- 9251 : LCS *LCS 대표 문제*
    - 행과 열 잘 셋팅하고
    - (1,2)에서 매칭이 일어났다는건 (0,2)에서 +1 됐다고 해석할 수 있다.
- 12865 : 평범한 배낭 *Knapsack 대표문제*
    - dp 차원 설정 잘하기
    - i번째 물건을 담을때, '그 물건을 담기 이전 상황 + 현 물건 가치'로 셋팅한다

==누적합 (6)==
- 2559 : 수열
    - for문 조건 식에서 엣지 범위 (포함하고 안하고) 잘 설정하기
- 16139 : 인간-컴퓨터 상호작용
    - row보다 column을 길게 잡아야 유리하다
    - for문 안에서 bw.write()하고 그 밖에서 bw.flush()해야 시간초과 안 걸린다
- 10986 : 나머지 합
    - [a, b] = [1,b] - [1, a-1]
    - sum(b) % M - sum(a-1) % M == 0
    - sum(b) % M == sum(a-1) % M
    - 나머지가 같은 두 인덱스를 뽑는 경우의 수로 조합을 사용함
    - 이차원으로 하면 시간초과 or 메모리부족
- 25682 : 체스판 다시 칠하기 2
    - 좌상단이 흑일때, 백일때 두 케이스로 2차원 배열의 누적합을 구한다.
    - 이떄 dp(i, j)는 (i,j)까지 바꿔야하는 개수를 저장하는 형태임
    - 흑일때와 백일때 두 케이스를 만들고 난 후 각 케이스에 대해 K x K로 컷팅해서 구해줌
    - for (int i = 1; i <= N - K + 1; i++) 로 사이즈 NxN보드에 대해 K x K로 컷팅
    - 모든 가능한 체스판 중 최소값이 result에 저장됩니다.

==그리디 (5)==
- 1931 : 회의실배정 *Greedy 대표문제*
    - 하나의 활동을 선택하면 나머지 겹치지 않는 활동에 대해서 독립적이다 -> 탐욕 선택이 이후의 결과에 영향을 미치지 않는다
- 1541 : 잃어버린 괄호
    - -(a+b) 의 꼴로 괄호를 쳐줘야한다. 구현 방법은 Strangers Lab의 방법이 더 간단함
    - -(a+b)가 많으면 많을수록 무조건 좋은거니 즉 이 행위 자체가 독립적이니 그리디가 가능한거임
- 13305 : 주유소
    - i부터 조사하는데 다음 도시가 지금 도시보다 싸면 거기까지만 간다. 만약 다음 도시가 지금 도시 가격보다 크면 무시하고 지금 내 가격 유지한다.
    - 범위 잘 보고 long으로 고쳐야 맞음

==분할정복 (9)==
- 2630 : 색종이 만들기 *분할정복 대표문제*
    - 이중 for문 탐색 중 더러운 색깔 발견하면 split_conquer 하고 return으로 종료도 해줘야 한다.
    - 더러운 놈이 끼여있으면 무조건 4등분으로 분할해야하기 떄문에 더 탐색을 안해도 되니까.
    - 보드 전체가 1이거나 0일때의 케이스도 따로 취급해줘야한다.
    - Stranger lab 구현 방법이 더 간단함 (풀스캔 결과를 불리안으로 체크함)
- 1629 : 곱셈 *분할정복 대표문제, 다시풀기*
    - (A x B) mod C = (A mod C x B mod C) mod C
    - 10^11 = 10^5 x 10^5 x 10^1이다 후자의 10^5는 중복해서 해줄 필요가 없다. 즉 반으로 나눠서 한번만 탐색시키도록 한다.
    - 홀수일때, 짝수일때 구분해줘야한다
- 11401 : 이항 계수 3
    - 페르마 소정리
    - a^p mod p = a mod p -> a^(p-1) = 1 mod p
    - a x a^(p-2) = 1 mod p
- 2740 : 행렬 곱셈
    - 문제 안 좋음. 특정 수학 원리에 의존적임
    - 그냥 행렬곱 구현해도 통과됨
- 10830 : 행렬 제곱
    - 1629번 + 2740번

==이분탐색 (7)==
- 1920 : 수 찾기 *Binary Search 대표문제*
    - 인덱스 시작을 1부터 할거면 소팅할때
    - Arrays.sort(arr, 1, n + 1); 써야함
- 10816 : 숫자 카드 2 *다시*
    - 10000000 배열 음양용으로 두 개 준비해서 소팅없이 단순하게 풀어도 풀리긴함
    - 1920번에서 찾은 mid값 기준 좌우로 범위 스캔하는건 다 시간초과 걸렸음
        - start -> mid 가면서 일치하는 값을 cnt += mid - i로 해도 시간초과
        - mid -> start 가면서 arr(i)값 다르면 break해도 시간초과
    - Stranger's LAB
        - lower bound : 하한은 찾고자 하는 특정 값 '이상'인 '첫 위치'를 반환
        - upper bound : 상한은 찾고자 하는 특정 값을 '초과'하는 '첫 위치'를 반환
        - 중복 원소에 대한 길이 = upper bound - lower bound (low <= idx < high)
            - 만약 원소가 존재하지 않는다면 상한과 하한 모두 같은 인덱스를 가리키고 있을 것이기에 0이 되므로 이 또한 존재하지 않는 원소를 찾으려 할 경우의 예외 또한 안전
            - 즉 low<=idx 이기에 key <= arr(mid)로 lower bound 설정
            - idx < high 이기에 key < arr(mid)로 upper bound 설정

- 1654 : 랜선 자르기
    - parametric search
    - 바킹독 피셜 과감하게 재껴도 된다
    - mid길이로 잘랐을 때의 개수가 만들고자 하는 랜선의 개수보다 작다면
    * 자르고자 하는 길이를 줄이기 위해 최대 길이를 줄인다.
    * 그 외에는 자르고자 하는 길이를 늘려야 하므로 최소 길이를 늘린다.
    * 특정 인덱스를 구하는게 아닌 길이를 구해야하기에 정렬도 필요 없다
    - mid = (max + min) / 2; 에서 max가 길이가 1일때의 케이스 처리해줘야함
- 2805 : 나무 자르기
    - 정답 맞췄고 풀다 보니 max값을 감소시키는 꼴이 됐긴함
    - 상관없음.
    - 생각보다 쉽네 손으로 써서 적당히 해보면 금방 나옴
- 2110 : 공유기 설치
    - 결국 최소 거리가 최대가 되기 위해서는 첫 번째 집은 설치가 되어있어야 함
    - 첫 번째 집에서 앞부분에 빈공간이 공간이 남는만큼 결국 최소거리가 점점 줄어들게되겠죠
    - *입력 10억짜리면 대부분 이분탐색이다*
    - 가장 인접한 두 공유기 사이 거리를 mid라고 하고 공유기를 설치하는 방법으로 푼다
    - mid 거리에 대해 설치 가능한 공유기 개수가 M 개수에 못미치면 거리를 좁혀야하니 hi를 mid 만큼 줄인다.
    - 설치 가능한 공유기 개수가 M 개수보다 크거나 같으면 거리를 벌리면서 최소 거리가 가질 수 있는 최대거리를 찾기 위해 low = mid + 1 해주면서 체크한다.
    - Upper Bound는 탐색 값을 초과하는 첫 번째 값을 가리키므로, low에서 1을 빼준 값이 조건식 만족하는 최대값이 됨
    - [7. 이분 탐색 - 문제](https://www.youtube.com/watch?v=Wbhwlf4stfY)
- 1300 (k번쨰 수), 12015(가장 긴 증가하는 부분 수열 2) 난이도 이슈로 스킵함

==우선순위 큐 (3)==
- 쉬워서 다 풂
- int compare(Integer o1, Integer o2)로 오버라이딩 하는거 알아보기
- pq : 우선순위가 가장 높은 요소(가장 작은 값)이 항상 루트에 오도록 유지한다
- 13975 : 파일 합치기 3
  - pq의 개념으로 푼다. 연속의 조건이 없기에 가장 작은 얘들 두 개를 합쳐서 add 해주고 끝날때 까지 반복하면 된다.

==동적계획법2 (6)==
- 동전 1만 골4이고 나머진 골3임 <- 다 풀어보자

- 11066 : 파일 합치기
  - "두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합침"
    - 이 이유 떄문에 pq를 쓸 수 가 없음.
    - pq는 연속성을 보장 받지 못하기때문
    - 연속이기에 파일을 합칠때 2일떄와 3일때만 고려해주면된다.
    - 즉 3개를 묶을땐 길이 내에서 2개씩 묶어 그 위치를 이동하면서 최소값을 찾아낸다. 코드 주석 참고
  - 점화식의 핵심은 i번 부터 j 까지 합한 최솟값이라 정의하는 거임
    - i파일이 j파일과 합쳤을 경우 같은 독립적인 정의 방식은 아무 쓸모가 없다.

==스택 2 (5)==

==그래프와 순회 (16)==

==최단경로 (7)==

==투포인터 (5)==

==동적계획법과 최단거리 역추적 (9)==

==트리 (7)==

==최소 신장 트리 (6)==

==트리에서의 동적 계획법 (4)==

==동적계획법3 (6)==


==??? 유니온 파인드 (4)==


- kmp, trie, 위상정렬은 투머치라는 의견
- 비트마스킹도 적당히만 알면됨
- 요즘은 문자열 파싱 자체를 하는 식으로 구현력을 많이 물어봄

